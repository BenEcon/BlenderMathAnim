import numpy as np
from anytree import RenderTree

from mathematics.groups.element import Element
from objects.tree.tree import Tree
from utils.utils import print_time_report


class Group:
    """
    generate a group from a set of generators
    type=='reduced': relations are applied immediately, only different elements are kept
    type=='free': all generators are considered to act freely, relations at the level of morphing

    the elements of the group are stored in the attribute: elements
    there is a word-element-dictionary: words

    """

    @classmethod
    def from_label(cls,label='CoxH3'):
        if label=='CoxH3':
            r5 = np.sqrt(5)
            generators = [
                Element(np.array([[-1,0,0],[0,1,0],[0,0,1]]),'a'),
                Element(np.array([[1/2,1/4*(-1+r5),1/4*(-1-r5)],[1/4*(-1+r5),1/4*(1+r5),1/2],[1/4*(-1-r5),1/2,1/4*(1-r5)]]),'b'),
                Element(np.array([[1,0,0],[0,1,0],[0,0,-1]]),'c'),
            ]
        else:
            generators = []

        return Group(*generators)

    def __init__(self, *generators, level=-1, dim=3,mode='reduced',action='right',**kwargs):
        self.kwargs = kwargs
        self.generators = generators
        self.level = level
        self.mode = mode

        if 'unit_string' in kwargs:
            self.unit_string=kwargs.pop('unit_string')
        else:
            self.unit_string='e'

        self.e = Element(np.identity(dim), '', group=self, **self.kwargs)
        self.elements = [self.e]  # store the elements of the group
        self.words = {self.unit_string: self.e}  # create a dictionary between words and group elements

        self.free_elements = [self.e]
        self.hashes = {hash(self.e): self.e}
        self.generate(action)

    def generate(self,action):
        new_elements = [self.e]
        if self.mode == 'reduced':
            while len(new_elements) > 0:
                brand_new_elements = []
                for old in new_elements:
                    for g in self.generators:
                        if action=='right':
                            next_one = old * g
                        else:
                            next_one = g * old
                        next_hash = hash(next_one)
                        if next_hash not in self.hashes:
                            brand_new_elements.append(next_one)
                            self.elements.append(next_one)
                            self.words[next_one.word] = next_one
                            self.hashes[next_hash] = next_one
                            next_one.parent = old
                new_elements = brand_new_elements
        elif self.mode == 'free':
            for i in range(self.level):
                brand_new_elements = []
                for old in new_elements:
                    for g in self.generators:
                        if action=='right':
                            next_one =old*g
                        else:
                            next_one = g*old
                        next_hash = hash(next_one)
                        if next_hash in self.hashes:
                            next_one.shortest_word = str(self.hashes[next_hash])
                        else:
                            self.elements.append(next_one)
                            self.hashes[next_hash] = next_one
                        self.free_elements.append(next_one)
                        brand_new_elements.append(next_one)
                        next_one.parent = old
                new_elements = brand_new_elements

    def __str__(self):
        return "group with " + str(len(self.elements)) + " elements generated by " + ','.join(
            [str(elem) for elem in self.elements])

    def shortest_word(self, element):
        sw = self.hashes[hash(element)].word
        return self.unit_string if sw == '' else sw

    def print_free_elements(self):
        for element in self.free_elements:
            print(element,self.shortest_word(element))

    def print_hashes(self):
        for hash in self.hashes:
            print(hash,self.hashes[hash])

    def print_tree(self):
        for pre, _ , node in RenderTree(self.elements[0]):
            tree_str = u"%s%s" % (pre, node.name)
            print(tree_str.ljust(8))


if __name__ == '__main__':
    try:
        print("Start with CoxA3: ")
        r2 = np.sqrt(2)
        a = Element(np.matrix([[-1, 0, 0], [0, 1, 0], [0, 0, 1]]), 'a')
        c = Element(np.matrix([[1, 0, 0], [0, 1, 0], [0, 0, -1]]), 'c')
        b = Element(-0.5 * np.matrix([[-1, r2, 1], [r2, 0, r2], [1, r2, -1]]), 'b')

        group = Group(a, b, c)
        print(group)

        for g in group.elements:
            print(g, ": ", g.shortest_word, ": ", g.matrix)

        print("Continue with CoxH3: ")
        group = Group.from_label("CoxH3")
        print(group)

        # for g in group.elements:
        #     print(g,": ",g.shortest_word,": ",g.matrix)

        b=group.elements[2]
        print((b*b).matrix)
    except:
        print_time_report()
        raise ()
